---
mainImage: ../../../images/part-1.svg
part: 1
letter: a
lang: ru
---

<div class="content">

Теперь мы начнем знакомство с, вероятно, самой важной темой данного курса, а именно библиотекой [React](https://reactjs.org/). Давайте начнем с создания простого приложения React и познакомимся с основными понятиями React.

Самый простой способ начать работу - использовать инструмент под названием [create-react-app](https://github.com/facebookincubator/create-react-app). Вы можете (но это не обязательно) установить <i>create-react-app</i> на вашем компьютере, если <i>npm</i>, который был установлен нами вместе с Node, имеет версию выше <i>5.3</i>.

Давайте создадим приложение <i>part1</i> с помощью <i>create-react-app</i> и перейдем в папку приложения.

```bash
$ npx create-react-app part1
$ cd part1
```

С этого момента каждая команда, начинающаяся с символа <em>$</em>, должна быть введена вами в командной строке терминала. Символ <em>$</em> вводить не нужно, поскольку он представляет собой [приглашение](https://pingvinus.ru/note/bash-promt).

Приложение запускается следующим образом:

```bash
$ npm start
```

По умолчанию приложение стартует на локальному порту 3000 с адресом <http://localhost:3000>

Chrome должен запуститься автоматически. **Обязательно** откройте консоль браузера и откройте текстовый редактор, чтобы вы могли одновременно просматривать и код и веб-страницу:

![](../../images/1/1e.png)

Код приложения находится в папке <i>src</i>. Давайте упростим стартовый код, изменив содержимое файла <i>index.js</i>:

```js
import React from 'react'
import ReactDOM from 'react-dom'

const App = () => (
  <div>
    <p>Hello world</p>
  </div>
)

ReactDOM.render(<App />, document.getElementById('root'))
```

Файлы <i>App.js</i>, <i>App.css</i>, <i>App.test.js</i>, <i>logo.svg</i> и <i>serviceWorker.js</i> можно удалить, поскольку они сейчас нам не нужны.

### Компонент

Теперь файл <i>index.js</i> определяет React-[компонент](https://ru.reactjs.org/docs/components-and-props.html) с именем <i>App</i>. и команда последней строки

```js
ReactDOM.render(<App />, document.getElementById('root'))
```

отображает его содержимое в элемент <i>div</i>, определенный в файле <i>public/index.html</i> и имеющий значение атрибута <i>id</i> равное 'root'.

По умолчанию файл <i>public/index.html</i> пуст. Вы можете попробовать добавить свой HTML в файл. Однако при использовании React весь контент, который необходимо отобразить, обычно определяется в компонентах React.

Давайте подробнее рассмотрим код, определяющий компонент:

```js
const App = () => (
  <div>
    <p>Hello world</p>
  </div>
)
```

Как вы, наверное, догадались, компонент будет отрисован в виде тега <i>div</i>, который содержит тег <i>p</i>, содержащий текст <i>Hello world</i>.

Технически компонент определяется как функция JavaScript. Ниже приведена функция, в которую не передаются параметры:

```js
() => (
  <div>
    <p>Hello world</p>
  </div>
)
```

Затем эта функция присваивается константе <i>App</i>:

```js
const App = ...
```

Есть несколько способов определить функцию в JavaScript. Здесь мы будем использовать [стрелочные функции](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions), которые описаны в более актуальной версии JavaScript, известной как [ECMAScript 6](http://es6-features.org/#Constants) или ES6.

Поскольку функция состоит только из одного выражения, мы использовали сокращение, которое по сути скрывает в себе этот фрагмент кода:

```js
const App = () => {
  return (
    <div>
      <p>Hello world</p>
    </div>
  )
}
```

Другими словами, функция возвращает значение выражения.

Функция, определяющая компонент, может содержать любой код JavaScript. Измените ваш компонент следующим образом и проверьте, что произошло в консоли:

```js
const App = () => {
  console.log('Hello from component')
  return (
    <div>
      <p>Hello world</p>
    </div>
  )
}
```

Кроме того есть возможнось отображать динамический контент внутри компонента.

Измените компонент следующим образом:

```js
const App = () => {
  const now = new Date()
  const a = 10
  const b = 20

  return (
    <div>
      <p>Hello world, it is {now.toString()}</p>
      <p>
        {a} plus {b} is {a + b}
      </p>
    </div>
  )
}
```

Любой код JavaScript в фигурных скобках выполняется, и результат этого выполнения встраивается в указанное место HTML, созданного компонентом.

### JSX

Кажется, что компоненты React возвращают HTML-разметку. Тем не менее, это не так. Структура React-компонент в основном пишется с использованием [JSX](https://ru.reactjs.org/docs/introducing-jsx.html). Хотя JSX выглядит как HTML, на самом деле мы имеем дело с методом написания JavaScript. JSX, возвращаемый компонентами React, компилируется (преобразуется) в JavaScript.

После компиляции наше приложение выглядит так:

```js
import React from 'react'
import ReactDOM from 'react-dom'

const App = () => {
  const now = new Date()
  const a = 10
  const b = 20
  return React.createElement(
    'div',
    null,
    React.createElement(
      'p', null, 'Hello world, it is ', now.toString()
    ),
    React.createElement(
      'p', null, a, ' plus ', b, ' is ', a + b
    )
  )
}

ReactDOM.render(
  React.createElement(App, null),
  document.getElementById('root')
)
```

За компиляцию отвечает [Babel](https://babeljs.io/repl/). Проекты, созданные с помощью *create-react-app*, уже настроены для автоматической компиляции. Подробнее об этой теме мы поговорим в [7 части](/ru/part7) этого курса.

Конечно, есть возможность писать на React, используя "чистый JavaScript" без использования JSX. Хотя, никто в здравом уме не сделает этого.

На практике JSX очень похож на HTML, с той лишь разницей, что в JSX вы можете легко встраивать динамический контент, написав соответствующий JavaScript-код в фигурных скобках. Идея JSX очень похожа на языки шаблонов, такие как Thymeleaf, используемые в Java Spring на серверах.

JSX - это [XML](https://developer.mozilla.org/ru/docs/Web/XML/XML_introduction), а значит каждый тег должен быть закрыт. Например, новая строка - это пустой элемент, который в HTML можно записать следующим образом:

```html
<br>
```

но при написании JSX тег должен быть закрыт:

```html
<br />
```

### Множество компонент

Давайте изменим приложение следующим образом (примечание: здесь и далее все импорты в верхней части <i>примеров</i> не будут показаны, но они все еще необходимы для работы кода):

```js
// highlight-start
const Hello = () => {
  return (
    <div>
      <p>Hello world</p>
    </div>
  )
}
// highlight-end

const App = () => {
  return (
    <div>
      <h1>Greetings</h1>
      <Hello /> // highlight-line
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById('root'))
```

Мы определили новый компонент <i>Hello</i> и использовали его внутри компонента <i>App</i>. Естественно, компонент может использоваться несколько раз:

```js
const App = () => {
  return (
    <div>
      <h1>Greetings</h1>
      <Hello />
      // highlight-start
      <Hello />
      <Hello />
      // highlight-end
    </div>
  )
}
```

Написание компонент с помощью React - легко, а благодаря возможности комбинирования компонент сложное приложение становится более поддерживаемым. И действительно, основная философия React - создание приложений из множества специализированных повторно используемых компонент.

Другим строгим соглашением является имя <i>App</i> для <i>root-компонента</i> - компонента в верхней части дерева приложения. Тем не менее, как мы узнаем из [6 части](/ru/part6), существуют ситуации, когда компонент <i>App</i> не является корнем, а заключен в соответствующий служебный компонент.

### props: пробрасываем данные в компоненты

Можно передавать данные в компоненты с помощью так называемых [пропсов](https://ru.reactjs.org/docs/components-and-props.html).

Давайте изменим компонент <i>Hello</i> следующим образом:

```js
const Hello = (props) => { // highlight-line
  return (
    <div>
      <p>Hello {props.name}</p> // highlight-line
    </div>
  )
}
```

Теперь функция, определяющая компонент, имеет параметр <i>props</i>. В качестве аргумента параметр получает объект, у которого есть поля, соответствующие всем "пропсам", которые определяет пользователь компонента.

Пропсы задаются следующим образом:

```js
const App = () => {
  return (
    <div>
      <h1>Greetings</h1>
      <Hello name="George" /> // highlight-line
      <Hello name="Daisy" /> // highlight-line
    </div>
  )
}
```

В коде может быть любое количество пропсов, и их значения могут быть "жестко заданными" строками или же результатами выполнения JavaScript. Если значение пропса вычисляется с помощью JavaScript, оно должно быть заключено в фигурные скобки.

Давайте изменим код так, чтобы компонент <i>Hello</i> использовал два пропса:

```js
const Hello = (props) => {
  return (
    <div>
      <p>
        Hello {props.name}, you are {props.age} years old // highlight-line
      </p>
    </div>
  )
}

const App = () => {
  const name = 'Peter' // highlight-line
  const age = 10       // highlight-line

  return (
    <div>
      <h1>Greetings</h1>
      <Hello name="Maya" age={26 + 10} /> // highlight-line
      <Hello name={name} age={age} />     // highlight-line
    </div>
  )
}
```

Пропсы, переданные компонентом <i>App</i> являются значениями переменных, результатом вычисления суммы и обычной строкой.

### Пару заметок

React сконфигурирован для генерации довольно четких и понятных сообщений об ошибках. Несмотря на это, в начале вам следует, продвигаться **очень маленькими шагами** и убедиться, что каждое изменение работает как нужно.

**Консоль всегда должна быть открыта**. Если браузер сообщает об ошибках, не пишите больше код, надеясь на чудо. Вместо этого попытайтесь понять причину ошибки и, например, вернитесь к предыдущему состоянию кода:

![](../../images/1/2a.png)

Не забывайте, что в React можно и нужно использовать команду <em>console.log()</em> (она выводит текст в консоль) в вашем коде.

Также имейте в виду, что **имена React-компонент должны быть заглавными**. Если вы попытаетесь определить компонент следующим образом:

```js
const footer = () => {
  return (
    <div>
      greeting app created by
      <a href="https://github.com/mluukkai">mluukkai</a>
    </div>
  )
}
```

и использовать его так:

```js
const App = () => {
  return (
    <div>
      <h1>Greetings</h1>
      <Hello name="Maya" age={26 + 10} />
      <footer /> // highlight-line
    </div>
  )
}
```

страница не будет отображать содержимое, определенное в компоненте Footer, и вместо этого React создает пустой элемент <i>footer</i>. Если вы измените первую букву имени компонента на заглавную, то React создаст элемент <i>div</i>, определенный в компоненте Footer, и отрисует его.

Обратите внимание, что содержимое компонента React (обычно) должно содержать **один корневой элемент**. Если мы, например, попытаемся определить компонент <i>App</i> без внешнего <i>div</i>-элемента:

```js
const App = () => {
  return (
    <h1>Greetings</h1>
    <Hello name="Maya" age={26 + 10} />
    <Footer />
  )
}
```

то мы получим ошибку:

![](../../images/1/3e.png)

Использование корневого элемента - не единственный верный вариант. <i>Массив</i> компонент также является допустимым решением:

```js
const App = () => {
  return [
    <h1>Greetings</h1>,
    <Hello name="Maya" age={26 + 10} />,
    <Footer />
  ]
}
```

Тем не менее, при определении корневого компонента приложения это не особо разумно, и делает код немного страннмм и уродливым.

Поскольку корневой элемент задан, у нас есть "лишние" div-элементы в DOM-дереве. Этого можно избежать, используя [фрагменты](https://ru.reactjs.org/docs/fragments.html) - оборачивая элементы, возвращаемые компонентом, в пустой элемент:

```js
const App = () => {
  const name = 'Peter'
  const age = 10

  return (
    <>
      <h1>Greetings</h1>
      <Hello name="Maya" age={26 + 10} />
      <Hello name={name} age={age} />
      <Footer />
    </>
  )
}
```

Теперь все успешно компилируется, и DOM, сгенерированный React, больше не содержит лишний div-элемент.

</div>

<div class="tasks">
  <h3>Упражнение 1.1.-1.2.</h3>

Упражнения отправляются через GitHub и помечаются как выполненные в [системе подачи упражнений](https://studies.cs.helsinki.fi/stats/courses/fullstackopen).

Вы можете отправить все упражнения в один и тот же репозиторий или использовать несколько разных репозиториев. Если вы отправляете упражнения из разных частей в один и тот же репозиторий, назовите ваши папки понятным способом. Если вы используете личный репозиторий для упражнений, добавьте аккаунт _mluukkai_ в качестве collaborator.

Хороший вариант назвать каталоги в вашем репозитории:

```
part0
part1
  courseinfo
  unicafe
  anecdotes
part2
  phonebook
  countries
```

Смотрите пример [тут](https://github.com/fullstack-hy2020/example-submission-repository)!

Таким образом, каждая часть имеет свой собственный каталог, который содержит каталог для каждого упражнения (например, упражнение unicafe в первой части).

Для каждого веб-приложения, созданного в рамках упражнений, рекомендуется предоставить все файлы, относящиеся к этому приложению, кроме каталога <i>node\_modules</i>.

Упражнения принимаются в формате **одна часть за один раз**. Когда вы отправили упражнения для пройденной части, вы больше не можете отправлять пропущенные упражнения для этой части.

Обратите внимание, что в этой части больше упражнений, чем приведено ниже. <i>Не отправляйте свою работу</i>, пока вы не выполнили все упражнения, которые вы хотите отправить для данной части.

  <h4>1.1: Информация о курсе, шаг 1</h4>

<i>Приложение, над которым мы начнем работать в этом упражнении, получит дальнейшее развитие в следующих упражнениях. В этом и других упражнениях курса достаточно лишь представить окончательный вариант приложения. При желании вы можете создать отдельный коммит для каждого упражнения, но это необязательно.</i>

Используйте create-react-app для инициализации нового приложения. Измените <i>index.js</i> следующим образом:

```js
import React from 'react'
import ReactDOM from 'react-dom'

const App = () => {
  const course = 'Half Stack application development'
  const part1 = 'Fundamentals of React'
  const exercises1 = 10
  const part2 = 'Using props to pass data'
  const exercises2 = 7
  const part3 = 'State of a component'
  const exercises3 = 14

  return (
    <div>
      <h1>{course}</h1>
      <p>
        {part1} {exercises1}
      </p>
      <p>
        {part2} {exercises2}
      </p>
      <p>
        {part3} {exercises3}
      </p>
      <p>Number of exercises {exercises1 + exercises2 + exercises3}</p>
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById('root'))
```

и удалите ненужные файлы (App.js, App.css, App.test.js, logo.svg, serviceWorker.js).

К сожалению, все приложение находится в одном компоненте. Измените код так, чтобы он состоял из трех новых компонентов: <i>Header</i>, <i>Content</i> и <i>Total</i>. Все данные должны по-прежнему находится в компоненте <i>App</i>, который передает их каждому компоненту с помощью <i>props</i>. <i>Header</i> выводит название курса, <i>Content</i> отображает разделы и количество упражнений в разделе, а <i>Total</i> отображает общее количество упражнений.

В итоге компонента <i>App</i> будет выглядеть следующим образом:

```js
const App = () => {
  // const-definitions

  return (
    <div>
      <Header course={course} />
      <Content ... />
      <Total ... />
    </div>
  )
}
```

**ПРЕДУПРЕЖДЕНИЕ** create-react-app автоматически инициализирует git в проекте, если этого еще не произошло. Скорее всего, вы **не хотите, чтобы** проект стал репозиторием, поэтому запустите команду _rm -rf .git_ в корне проекта.

<h4>1.2: Информация о курсе, шаг 2</h4>

Refactor the <i>Content</i> component so that it does not render any names of parts or their number of exercises by itself. Instead it only renders three <i>Part</i> components of which each renders the name and number of exercises of one part.

Выполните рефакторинг компонента <i>Content</i>. Вынесите отрисовку имен разделов и количества упражнений в отдельный компонент <i>Part</i>. В результате  у нас будет три компонента <i>Part</i>, каждый из которых отрисовывает свой раздел и количество упражнений этого раздела.

```js
const Content = ... {
  return (
    <div>
      <Part .../>
      <Part .../>
      <Part .../>
    </div>
  )
}
```

Наше приложение передает информацию довольно примитивным способом на данный момент, так как оно основано на отдельных переменных. Эта ситуация скоро изменится к лучшем.

</div>
